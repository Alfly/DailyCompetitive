## [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)

> Tag: 回文串 回溯 DP

[solution](https://leetcode-cn.com/problems/palindrome-partitioning/solution/hui-su-you-hua-jia-liao-dong-tai-gui-hua-by-liweiw/)

### 方法一：回溯
* 时间复杂度: ${O(n*2^n)}$ 有剪枝
* 空间复杂度: ${O(n)}$ 调用栈高度为 n
```cpp
class Solution {
public:
    vector<vector<string>> partition(string s) {
        int n = s.size();
        vector<vector<string>> res;
        vector<string> path;
        dfs(s, n, 0, path, res);
        return res;
    }
    void dfs(string s, int n, int u, vector<string>& path, vector<vector<string>> &res) {
        if (u == n) {
            res.push_back(path);
            return;
        }
        for (int i = u; i < n; i++) {
            if (!check(s, u, i)) continue;
            path.push_back(s.substr(u, i - u + 1));
            dfs(s, n, i + 1, path, res);
            path.pop_back();
        }
    }
    bool check(string s, int l, int r) {
        while (l < r) {
            if (s[l] != s[r]) return false;
            l++, r--;
        }
        return true;
    }
};
```

### 方法二：回溯 + DP预处理
* 时间复杂度: ${O(n+2^n)}$
* 空间复杂度: ${O(n^2)}$
```cpp
class Solution {
public:
    vector<vector<string>> partition(string s) {
        int n = s.size();
        vector<vector<bool>> f(n, vector<bool>(n));
        for (int i = 0; i < n; i++) {
            f[i][i] = true;
            if (i >= 1) f[i][i - 1] = true;
        }
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) {
                if (s[i] == s[j]) f[i][j] = f[i + 1][j - 1];
                else f[i][j] = false;
            }
        }
        vector<vector<string>> res;
        vector<string> path;
        dfs(s, 0, path, res, f);
        return res;
    }
    void dfs(string s, int i, vector<string>& path, 
            vector<vector<string>>& res, vector<vector<bool>>& f) {
        int n = s.size();
        if (i == n) {
            res.push_back(path);
            return;
        }
        for (int j = i; j < n; j++) {
            if (!f[i][j]) continue;
            path.push_back(s.substr(i, j - i + 1));
            dfs(s, j + 1, path, res, f);
            path.pop_back();
        }
    }
};
```